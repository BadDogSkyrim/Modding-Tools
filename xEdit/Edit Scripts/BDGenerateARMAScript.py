"""
Generates an xEdit script that creates an armor addon record corresponding to each .nif file in a
folder tree. Run this script, then run the generated script in xEdit. 

The generated headparts will have EDIDs of the form {path_to_nif}_{nif_name}.
"""


import os
from pathlib import Path
from collections import namedtuple

# --- Config ---
search_dir = r"C:\Users\hughr\AppData\Roaming\Vortex\skyrimse\mods\YAS Canine Armor Working\meshes\YAS\armor"
output_pas = r"C:\Modding\GitTools\xEdit\Edit Scripts\GeneratedArmorAddons.pas"
target_plugin_name = "YASDogGear"  # plugin filename without extension
# --------------

ArmorNifPair = namedtuple('ArmorNifPair', ['root', 'male', 'fem'])

patterns = [('fdog', 'mdog'), ('dogf', 'dogm')]

def FilenameToEditorID(full_path: str) -> str:
    p = Path(full_path)
    parts = [part.lower() for part in p.parts]
    meshes_idx = parts.index('meshes')
    rel_parts = p.parts[meshes_idx+1:-1]
    fn = p.stem[0:-2] if p.stem.endswith('_1') else p.stem
    rel_str = "_".join(rel_parts) + "_" + fn
    return rel_str


def FindPair(nif: Path) -> ArmorNifPair:
    rootpart = nif.stem
    malepart = fempart = None
    fn = nif.stem[:-2] if nif.stem.endswith('_1') else nif.stem
    for ftag, mtag in patterns:
        if fn.endswith(ftag):
            rootpart = fn[:-len(ftag)]
            fempart = nif
            fn2 = rootpart + mtag
            nif2 = nif.with_name(fn2 + nif.suffix)
            if nif2.exists():
                malepart = nif2
    return ArmorNifPair(rootpart, malepart, fempart)


def FindArmorPairs(files: list) -> list:
    """
    Scans the given folder for .nif files and returns a list of (rootname, male_path, female_path) tuples.
    Male files contain 'male', 'm', female files contain 'female', 'fem', or 'f'.
    """
    male_tags = ['male', 'm']
    female_tags = ['female', 'fem', 'f']
    pairs = {}
    used = set()

    for filename in files:
        fname = filename.lower()
        if not fname.endswith('.nif') or filename in used:
            continue
        fname = fname[:-4]  # Strip .nif

        for taglist in [male_tags, female_tags]:
            for tag in taglist:
                match = False
                if len(tag) == 1:
                    match = fname.endswith(tag)
                    base = fname[:-1]
                else:
                    match = tag in fname 
                    base = fname.replace(tag, '')
                if match:
                    if base in pairs:
                        if taglist == male_tags:
                            pairs[base] = (filename, pairs[base][1])
                        else:
                            pairs[base] = (pairs[base][0], filename)
                    else:
                        if taglist == male_tags:
                            pairs[base] = (filename, None)
                        else:
                            pairs[base] = (None, filename)
    return pairs


with open(output_pas, "w", encoding="utf-8") as f:
    curdir = ''
    for root, dirs, files in os.walk(search_dir):
        print(f"{root}: \n{FindArmorPairs(files)}")

# def transform_edid(nif_filename):
#     """
#     Given a filename like 'DogFoo_Bar.nif':
#       - Strip leading 'Dog'
#       - Split at last underscore into base & suffix
#       - Move suffix to front, append base
#       -> 'BarFoo'
#     """
#     name_no_ext = os.path.splitext(nif_filename)[0]
#     if "_" not in name_no_ext:
#         return name_no_ext
#     stripped = name_no_ext[3:] if name_no_ext.startswith('Dog') else name_no_ext
#     base, suffix = stripped.rsplit("_", 1)
#     return f"{headpart_prefix}{suffix}{base}"



# def find_rel_path(full_path: str) -> str:
#     # Normalize to forward slashes for consistent splitting
#     norm_path = full_path.replace('\\', '/').lower()
    
#     # Find the 'meshes' segment
#     marker = 'meshes/'
#     idx = norm_path.find(marker)
#     if idx == -1:
#         return ''  # 'meshes' not found

#     # Slice the original (case-preserving) string right after 'meshes/'
#     case_preserved = full_path.replace('\\', '/')
#     rel_path = case_preserved[idx + len(marker):]

#     return rel_path

    
# with open(output_pas, "w", encoding="utf-8") as f:
#     f.write("{ Auto-generated by Python â€” for use in xEdit }\n")
#     f.write("unit userscript;\n\n")
#     f.write("var\n  headPart: IInterface;\n  targetFile: IInterface;\n\n")
#     f.write("// Returns a newly created main record of the given signature in aFile.\n")
#     f.write("// Uses only stock xEdit routines: GroupBySignature and Add.\n")
#     f.write("function AddNewRecord(aFile: IInterface; sig: string): IInterface;\n")
#     f.write("var\n")
#     f.write("  grp: IInterface;\n")
#     f.write("begin\n")
#     f.write("  Result := nil;\n")
#     f.write("  if not Assigned(aFile) or (Length(sig) <> 4) then\n")
#     f.write("    Exit;\n")
#     f.write("\n")
#     f.write("  // Get or create the target group inside the file\n")
#     f.write("  grp := GroupBySignature(aFile, sig);\n")
#     f.write("  if not Assigned(grp) then\n")
#     f.write("    grp := Add(aFile, sig, True); // creates the group if missing\n")
#     f.write("\n")
#     f.write("  if not Assigned(grp) then\n")
#     f.write("    Exit;\n")
#     f.write("\n")
#     f.write("  // Add the new record to the group and return it\n")
#     f.write("  Result := Add(grp, sig, True);\n")
#     f.write("end;\n\n")
#     f.write("function Initialize: integer;\n")
#     f.write("var e: IInterface;\n")
#     f.write("begin\n")
#     f.write(f"  targetFile := FileByName('{target_plugin_name}.esp');\n")
#     f.write("  if not Assigned(targetFile) then\n")
#     f.write(f"  begin\n    targetFile := FileByName('{target_plugin_name}.esm');\n  end;\n")
#     f.write("  if not Assigned(targetFile) then\n")
#     f.write("  begin\n    AddMessage('Target plugin not found');\n    Result := 1;\n    exit;\n  end;\n\n")

#     basepath = find_rel_path(search_dir)
#     for root, dirs, files in os.walk(search_dir):
#         for file in files:
#             if file.lower().endswith(".nif"):
#                 full_path = os.path.join(root, file)
#                 rel_nif = basepath + '/' + os.path.relpath(full_path, search_dir).replace("\\", "/")
#                 edid = transform_edid(file)

#                 expr_tri, chargen_tri = find_tri_files(full_path)
#                 rel_expr = basepath + '/' + os.path.relpath(expr_tri, search_dir).replace("\\", "/") if expr_tri else ""
#                 rel_chargen = basepath + '/' + os.path.relpath(chargen_tri, search_dir).replace("\\", "/") if chargen_tri else ""

#                 f.write(f"  headPart := AddNewRecord(targetFile, 'HDPT');\n")
#                 f.write(f"  SetElementEditValues(headPart, 'EDID', '{edid}');\n")
#                 f.write(f"  Add(headpart, 'Model', True);\n")
#                 f.write(f"  SetElementEditValues(headPart, 'Model\\MODL', '{rel_nif}');\n")
#                 f.write(f"  Add(headpart, 'Parts', True);\n")
#                 if rel_expr:
#                     f.write(f"  e := ElementByIndex(ElementByPath(headpart, 'Parts'), 0);\n")
#                     f.write(f"  SetElementEditValues(e, 'NAM0', 'Tri');\n")
#                     f.write(f"  SetElementEditValues(e, 'NAM1', '{rel_expr}');\n")
#                 if rel_chargen:
#                     f.write(f"  e := ElementAssign(ElementByPath(headpart, 'Parts'), HighInteger, nil, False);\n")
#                     f.write(f"  SetElementEditValues(e, 'NAM0', 'Chargen Morph');\n")
#                     f.write(f"  SetElementEditValues(e, 'NAM1', '{rel_chargen}');\n")
#                 f.write("\n")

#     f.write("end;\n\nend.\n")

# print(f"Pascal script generated: {output_pas}")