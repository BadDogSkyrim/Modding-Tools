"""
Generates an xEdit script that creates a headpart corresponding to each .nif file in a
folder. Run this script, then run the generated script in xEdit. Expression and chargen
tris are associated if they exist.

Nifs are assumed to have the name format {prefix}{basename}_{suffix}.nif, and 
the generated headparts will have EDIDs of the form {headpart_prefix}{suffix}{basename}.
"""

import os
from pathlib import Path
from datetime import datetime

# --- Config ---
search_dir = r"C:\Users\hughr\AppData\Roaming\Vortex\skyrimse\mods\Cat Races-44919-2-2-1611793835\meshes\YAS\Feline\Earrings\Male"
output_pas = r"C:\Modding\GitTools\xEdit\Edit Scripts\GeneratedHeadParts.pas"
target_plugin_name = "BDCatRaces"  # plugin filename without extension
headpart_prefix = "YAS"  # prefix for EDID of generated headparts
LEADING_TEXT = "Cat"
# --------------

def transform_edid(nif_filename):
    """
    Given a filename like 'DogFoo_Bar.nif':
      - Strip leading 'Dog'
      - Split at last underscore into base & suffix
      - Move suffix to front, append base
      -> 'BarFoo'
    """
    name_no_ext = os.path.splitext(nif_filename)[0]
    if "_" not in name_no_ext:
        return name_no_ext
    stripped = name_no_ext[len(LEADING_TEXT):] if name_no_ext.startswith(LEADING_TEXT) else name_no_ext
    base, suffix = stripped.rsplit("_", 1)
    return f"{headpart_prefix}{suffix}{base}"

def find_tri_files(nif_path):
    base_dir = os.path.dirname(nif_path)
    base_name = os.path.splitext(os.path.basename(nif_path))[0]
    expr_tri = os.path.join(base_dir, base_name + ".tri")
    expr_tri = expr_tri if os.path.isfile(expr_tri) else ""
    chargen_candidates = [
        os.path.join(base_dir, base_name + "_Chargen.tri"),
        os.path.join(base_dir, base_name + "Chargen.tri"),
    ]
    chargen_tri = next((p for p in chargen_candidates if os.path.isfile(p)), "")
    return expr_tri, chargen_tri

def find_rel_path(full_path: str) -> str:
    # Normalize to forward slashes for consistent splitting
    norm_path = full_path.replace('\\', '/').lower()
    
    # Find the 'meshes' segment
    marker = 'meshes/'
    idx = norm_path.find(marker)
    if idx == -1:
        return ''  # 'meshes' not found

    # Slice the original (case-preserving) string right after 'meshes/'
    case_preserved = full_path.replace('\\', '/')
    rel_path = case_preserved[idx + len(marker):]

    return rel_path

with open(output_pas, "w", encoding="utf-8") as f:
    f.write(f"""
//  For use in xEdit. Auto-generated by {Path(__file__).name} on {datetime.now()}.
unit userscript;
var
  headPart: IInterface;
  targetFile: IInterface;

// Returns a newly created main record of the given signature in aFile.
// Uses only stock xEdit routines: GroupBySignature and Add.
function AddNewRecord(aFile: IInterface; sig: string): IInterface;
var
  grp: IInterface;
begin
  Result := nil;
  if not Assigned(aFile) or (Length(sig) <> 4) then
    Exit;

  // Get or create the target group inside the file
  grp := GroupBySignature(aFile, sig);
  if not Assigned(grp) then
    grp := Add(aFile, sig, True); // creates the group if missing

  if not Assigned(grp) then
    Exit;

  // Add the new record to the group and return it
  Result := Add(grp, sig, True);
end;

function Initialize: integer;
var e: IInterface;
begin
  targetFile := FileByName('{target_plugin_name}.esp');
  if not Assigned(targetFile) then
  begin
    targetFile := FileByName('{target_plugin_name}.esm');
  end;
  if not Assigned(targetFile) then
  begin
    AddMessage('Target plugin not found');
    Result := 1;
    exit;
  end;
""")
    
    basepath = find_rel_path(search_dir)
    for root, dirs, files in os.walk(search_dir):
        for file in files:
            if file.lower().endswith(".nif"):
                full_path = os.path.join(root, file)
                rel_nif = basepath + '/' + os.path.relpath(full_path, search_dir).replace("\\", "/")
                edid = transform_edid(file)

                expr_tri, chargen_tri = find_tri_files(full_path)
                rel_expr = basepath + '/' + os.path.relpath(expr_tri, search_dir).replace("\\", "/") if expr_tri else ""
                rel_chargen = basepath + '/' + os.path.relpath(chargen_tri, search_dir).replace("\\", "/") if chargen_tri else ""

                f.write(f"""
  headPart := AddNewRecord(targetFile, 'HDPT');
  SetElementEditValues(headPart, 'EDID', '{edid}');
  Add(headpart, 'Model', True);
  SetElementEditValues(headPart, 'Model\\MODL', '{rel_nif}');
  Add(headpart, 'Parts', True);

""")
                if rel_expr:
                    f.write(f"""
  e := ElementByIndex(ElementByPath(headpart, 'Parts'), 0);
  SetElementEditValues(e, 'NAM0', 'Tri');
  SetElementEditValues(e, 'NAM1', '{rel_expr}');
                            
""")
                if rel_chargen:
                    f.write(f"""
  e := ElementAssign(ElementByPath(headpart, 'Parts'), HighInteger, nil, False);
  SetElementEditValues(e, 'NAM0', 'Chargen Morph');
  SetElementEditValues(e, 'NAM1', '{rel_chargen}');
""")

    f.write("""
end;
            
end.
""")

print(f"Pascal script generated: {output_pas}")